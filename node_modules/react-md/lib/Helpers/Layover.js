(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['exports', 'react', 'react-dom', 'prop-types', 'react-transition-group/CSSTransitionGroup', 'classnames', '../utils/EventUtils/captureNextEvent', '../utils/EventUtils/handleWindowClickListeners', '../utils/getSelectedTextPosition', '../utils/getScroll', '../utils/viewport', '../utils/isOutOfBounds', './anchorShape', './fixedToShape', './positionShape', './HorizontalAnchors', './VerticalAnchors', './Positions', './ResizeObserver'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require('react'), require('react-dom'), require('prop-types'), require('react-transition-group/CSSTransitionGroup'), require('classnames'), require('../utils/EventUtils/captureNextEvent'), require('../utils/EventUtils/handleWindowClickListeners'), require('../utils/getSelectedTextPosition'), require('../utils/getScroll'), require('../utils/viewport'), require('../utils/isOutOfBounds'), require('./anchorShape'), require('./fixedToShape'), require('./positionShape'), require('./HorizontalAnchors'), require('./VerticalAnchors'), require('./Positions'), require('./ResizeObserver'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.react, global.reactDom, global.propTypes, global.CSSTransitionGroup, global.classnames, global.captureNextEvent, global.handleWindowClickListeners, global.getSelectedTextPosition, global.getScroll, global.viewport, global.isOutOfBounds, global.anchorShape, global.fixedToShape, global.positionShape, global.HorizontalAnchors, global.VerticalAnchors, global.Positions, global.ResizeObserver);
    global.Layover = mod.exports;
  }
})(this, function (exports, _react, _reactDom, _propTypes, _CSSTransitionGroup, _classnames, _captureNextEvent, _handleWindowClickListeners, _getSelectedTextPosition, _getScroll, _viewport, _isOutOfBounds, _anchorShape, _fixedToShape, _positionShape, _HorizontalAnchors, _VerticalAnchors, _Positions, _ResizeObserver) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react2 = _interopRequireDefault(_react);

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _CSSTransitionGroup2 = _interopRequireDefault(_CSSTransitionGroup);

  var _classnames2 = _interopRequireDefault(_classnames);

  var _captureNextEvent2 = _interopRequireDefault(_captureNextEvent);

  var _handleWindowClickListeners2 = _interopRequireDefault(_handleWindowClickListeners);

  var _getSelectedTextPosition2 = _interopRequireDefault(_getSelectedTextPosition);

  var _getScroll2 = _interopRequireDefault(_getScroll);

  var _viewport2 = _interopRequireDefault(_viewport);

  var _isOutOfBounds2 = _interopRequireDefault(_isOutOfBounds);

  var _anchorShape2 = _interopRequireDefault(_anchorShape);

  var _fixedToShape2 = _interopRequireDefault(_fixedToShape);

  var _positionShape2 = _interopRequireDefault(_positionShape);

  var _HorizontalAnchors2 = _interopRequireDefault(_HorizontalAnchors);

  var _VerticalAnchors2 = _interopRequireDefault(_VerticalAnchors);

  var _Positions2 = _interopRequireDefault(_Positions);

  var _ResizeObserver2 = _interopRequireDefault(_ResizeObserver);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Layover = function (_PureComponent) {
    _inherits(Layover, _PureComponent);

    function Layover(props, context) {
      _classCallCheck(this, Layover);

      var _this = _possibleConstructorReturn(this, (Layover.__proto__ || Object.getPrototypeOf(Layover)).call(this, props, context));

      _initialiseProps.call(_this);

      var child = _react2.default.Children.only(props.children);
      _this.state = {
        below: false,
        right: false,
        styles: child.props.style
      };

      _this._lastXFix = null;
      _this._lastYFix = null;
      _this._initialX = null;
      _this._initialY = null;
      _this._initialTop = null;
      _this._initialLeft = null;
      _this._childLeft = null;
      _this._childRight = null;
      _this._child = null;
      _this._toggle = null;
      return _this;
    }

    _createClass(Layover, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        if (process.env.NODE_ENV === 'development') {
          window.addEventListener('load', function () {
            _this2._setContainer(_this2._container);
          });
        }

        var _props = this.props,
            visible = _props.visible,
            fixedTo = _props.fixedTo,
            sameWidth = _props.sameWidth,
            centered = _props.centered;

        var anchor = this._getAnchor(this.props);
        if (visible) {
          (0, _handleWindowClickListeners2.default)(this._handleOutsideClick, true);
          var rect = this._contextRect || this._toggle.getBoundingClientRect();
          if (this._dialog) {
            this._manageFixedToListener(this._dialog, true);
          } else if (!this._inFixed) {
            this._manageFixedToListener(fixedTo, true);
          }

          this._init(fixedTo, anchor, sameWidth, centered, rect);
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var fixedTo = nextProps.fixedTo,
            visible = nextProps.visible,
            children = nextProps.children,
            sameWidth = nextProps.sameWidth,
            centered = nextProps.centered;

        var anchor = this._getAnchor(nextProps);
        var visibileDiff = visible !== this.props.visible;
        var childStyle = _react2.default.Children.only(children).props.style;

        if (!visibileDiff && fixedTo !== this.props.fixedTo && visible) {
          this._manageFixedToListener(this.props.fixedTo, false);
          this._manageFixedToListener(fixedTo, true);
        } else if (visibileDiff && visible) {
          var rect = this._contextRect || this._toggle.getBoundingClientRect();
          if (this._dialog) {
            this._manageFixedToListener(this._dialog, true);
          } else if (!this._inFixed) {
            this._manageFixedToListener(fixedTo, true);
          }

          this._init(fixedTo, anchor, sameWidth, centered, rect);
        } else if (visibileDiff && !visible && !this._inFixed) {
          if (this._dialog) {
            this._manageFixedToListener(this._dialog, false);
          }
          this._manageFixedToListener(fixedTo, false);
        } else if (childStyle !== _react2.default.Children.only(this.props.children).props.style) {
          // Re-merge styles...
          this.setState({ styles: _extends({}, this.state.styles, childStyle) });
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        var _props2 = this.props,
            visible = _props2.visible,
            closeOnOutsideClick = _props2.closeOnOutsideClick;

        if (visible !== prevProps.visible && closeOnOutsideClick) {
          (0, _handleWindowClickListeners2.default)(this._handleOutsideClick, visible);
        } else if (closeOnOutsideClick !== prevProps.closeOnOutsideClick && visible) {
          (0, _handleWindowClickListeners2.default)(this._handleOutsideClick, closeOnOutsideClick);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this._manageFixedToListener(this.props.fixedTo, false);
        (0, _handleWindowClickListeners2.default)(this._handleOutsideClick, false);
        window.removeEventListener('resize', this._handleWindowResize);
      }
    }, {
      key: '_getAnchor',
      value: function _getAnchor(_ref) {
        var anchor = _ref.anchor,
            belowAnchor = _ref.belowAnchor,
            animationPosition = _ref.animationPosition;

        return animationPosition === Layover.Positions.BELOW && belowAnchor || anchor;
      }
    }, {
      key: '_createStyles',
      value: function _createStyles(anchor, centered, child, rect) {
        var x = anchor.x,
            y = anchor.y;
        var offsetWidth = child.offsetWidth,
            offsetHeight = child.offsetHeight;


        var left = void 0;
        var top = void 0;
        if (x === _HorizontalAnchors2.default.CENTER) {
          var _child$getBoundingCli = child.getBoundingClientRect(),
              childLeft = _child$getBoundingCli.left;

          left = childLeft + rect.width / 2 - offsetWidth / 2;
        } else if (x === _HorizontalAnchors2.default.INNER_RIGHT) {
          left = rect.right - offsetWidth;
        } else if (x === _HorizontalAnchors2.default.LEFT) {
          left = rect.left - offsetWidth;
        }

        if (centered && x === _HorizontalAnchors2.default.CENTER && y === _VerticalAnchors2.default.CENTER) {
          top = rect.top - offsetHeight / 2 + rect.height / 2;
        } else if (y === _VerticalAnchors2.default.TOP) {
          top = rect.top - offsetHeight;
        } else if (y === _VerticalAnchors2.default.CENTER) {
          top = rect.top + rect.height / 2;
        } else if (y === _VerticalAnchors2.default.BOTTOM) {
          top = rect.bottom;
        }

        var style = {};
        if (top) {
          style.top = top;
        }

        if (left) {
          style.left = left;
        }

        return style;
      }
    }, {
      key: 'render',
      value: function render() {
        var _props3 = this.props,
            className = _props3.className,
            block = _props3.block,
            toggle = _props3.toggle,
            visible = _props3.visible,
            children = _props3.children,
            fullWidth = _props3.fullWidth,
            animationPosition = _props3.animationPosition,
            anchor = _props3.anchor,
            belowAnchor = _props3.belowAnchor,
            onClose = _props3.onClose,
            repositionOnScroll = _props3.repositionOnScroll,
            sameWidth = _props3.sameWidth,
            centered = _props3.centered,
            fixedTo = _props3.fixedTo,
            toggleQuery = _props3.toggleQuery,
            yThreshold = _props3.yThreshold,
            xThreshold = _props3.xThreshold,
            onContextMenu = _props3.onContextMenu,
            preventContextMenu = _props3.preventContextMenu,
            closeOnOutsideClick = _props3.closeOnOutsideClick,
            props = _objectWithoutProperties(_props3, ['className', 'block', 'toggle', 'visible', 'children', 'fullWidth', 'animationPosition', 'anchor', 'belowAnchor', 'onClose', 'repositionOnScroll', 'sameWidth', 'centered', 'fixedTo', 'toggleQuery', 'yThreshold', 'xThreshold', 'onContextMenu', 'preventContextMenu', 'closeOnOutsideClick']);

        var child = void 0;
        var childId = void 0;
        if (visible) {
          child = _react2.default.Children.only(children);
          if (child.props.id) {
            childId = child.props.id;
          } else if (props.id) {
            childId = props.id + '-layover';
          }

          child = _react2.default.cloneElement(children, {
            ref: this._fixateChild,
            id: childId,
            style: this.state.styles,
            className: (0, _classnames2.default)('md-layover-child md-layover-child--' + animationPosition, child.props.className)
          });
        }

        return _react2.default.createElement(
          _CSSTransitionGroup2.default,
          _extends({}, props, {
            className: (0, _classnames2.default)('md-layover', {
              'md-inline-block': !block && !fullWidth,
              'md-full-width': fullWidth
            }, className),
            ref: this._setContainer,
            'aria-haspopup': true,
            'aria-owns': childId,
            'aria-expanded': visible,
            transitionEnter: props.transitionEnterTimeout !== 0,
            transitionLeave: props.transitionLeaveTimeout !== 0,
            onContextMenu: this._handleContextMenu
          }),
          _react2.default.createElement(_ResizeObserver2.default, { watchWidth: true, watchHeight: true, target: this._child, onResize: this._handleResize }),
          toggle,
          child
        );
      }
    }]);

    return Layover;
  }(_react.PureComponent);

  Layover.HorizontalAnchors = _HorizontalAnchors2.default;
  Layover.VerticalAnchors = _VerticalAnchors2.default;
  Layover.Positions = _Positions2.default;
  Layover.propTypes = {
    /**
     * A id to give the layover itself. This is generally recommended for accessibility. If the
     * child does not have an id, the child will automatically be updated to be `${id}-layover`.
     */
    id: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),

    /**
     * An optional style to apply to the layover.
     */
    style: _propTypes2.default.object,

    /**
     * An optional className to apply to the layover.
     */
    className: _propTypes2.default.string,

    /**
     * Boolean if the layover's child is currently visible.
     */
    visible: _propTypes2.default.bool.isRequired,

    /**
     * This should either be a single element or two elements that the layover recalculates
     * its fixed position when scrolling for horizontal and vertical.
     *
     * When it is a single element, it will recalculate for both horizontal and vertical
     * scrolling. Otherwise, you can specify the element for horizontal scrolling and a
     * separate element for vertical scrolling. If one is omitted, it will default to `window`.
     *
     * If the component is no longer considered to be in view after scrolling, the `onClose`
     * prop will be called.
     */
    fixedTo: _fixedToShape2.default.isRequired,

    /**
     * The renderable item that causes the Layover to become visible. This _should_
     * most likely be an `element` or `arrayOf(element)`, but anything is allowed.
     */
    toggle: _propTypes2.default.node,

    /**
     * Since the `toggle` prop can be anything, I need a way to be able to find an
     * element to base all the calculations on. This can either be a string that
     * gets passed to `layover.querySelector`, a DOM Element, or a function that
     * returns a DOM Element.
     */
    toggleQuery: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object, _propTypes2.default.string]).isRequired,

    /**
     * A single child that should be fixed to the toggle element.
     */
    children: _propTypes2.default.element.isRequired,

    /**
     * Boolean if the Layover should be displayed as a block instead of as an inline block.
     */
    block: _propTypes2.default.bool,

    /**
     * Boolean if the `children` should be centered horizontally and vertically while keeping
     * its height in mind as well. This is *only* valid if both the x and y `anchor` targets
     * are `CENTER`.
     */
    centered: _propTypes2.default.bool,

    /**
     * Boolean if the layover should gain the `md-full-width` class name.
     */
    fullWidth: _propTypes2.default.bool,

    /**
     * Boolean if the width of the children should be updated automatically to be the width
     * of the toggle element.
     */
    sameWidth: _propTypes2.default.bool,

    /**
     * A function used to hide the visibility of the children when the children are no longer
     * visible or an element outside of the layover is clicked.
     */
    onClose: _propTypes2.default.func.isRequired,

    /**
     * The component to render the Layover as.
     */
    component: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]).isRequired,

    /**
     * The transition name to use for the children appearing/disappearing.
     */
    transitionName: _propTypes2.default.string.isRequired,

    /**
     * The transition duration for the enter animation. The animation can be disabled by setting
     * this value to 0.
     */
    transitionEnterTimeout: _propTypes2.default.number.isRequired,

    /**
     * The transition duration for the leave animation. The animation can be disabled by setting
     * this value to 0.
     */
    transitionLeaveTimeout: _propTypes2.default.number.isRequired,

    /**
     * This is a threshold that is used to calculate if the `children` is still in
     * view by applying this multiplier to the `children`'s width.
     */
    xThreshold: _propTypes2.default.number.isRequired,

    /**
     * This is a threshold that is used to calculate if the `children` is still in
     * view by applying this multiplier to the `toggle`'s height.
     */
    yThreshold: _propTypes2.default.number.isRequired,

    /**
     * Boolean if the `children` should be hidden when an element outside
     * of the `Layout` component has been clicked.
     */
    closeOnOutsideClick: _propTypes2.default.bool.isRequired,

    /**
     * This is how the children get "anchored" to the `toggle` element and how the
     * auto-fix attempts will be made. Right now, the auto fixes will only be handled
     * on viewport boundaries instead of `fixedTo` boundaries. It was too hard for
     * first attempt.
     *
     * The general behavior will be that an equal-opposite of an anchor will be chosen
     * when that direction is out of viewport. So for example, the children are out
     * of viewport for the right of the screen, and the `anchor.x` value is
     * `Layover.HorizontalPositions.RIGHT`, the children will be swapped to be the `LEFT`
     * of the `toggle` component now.
     *
     * So a full list:
     * - `LEFT` / `RIGHT`
     * - `INNER_LEFT` / `INNER_RIGHT`
     * - `TOP` / `BOTTOM`
     *
     * The `CENTER` and `OVERLAP` positions can not be automatically adjusted.
     *
     * > To be safe, you should use the enum values for the `x` and `y` values.
     * @see {@link #VerticalAnchors}
     * @see {@link #HorizontalAnchors}
     */
    anchor: _anchorShape2.default.isRequired,

    /**
     * This is how the children get "anchored" when the `animationPositions` is set to `Layover.Positions.BELOW`.
     * Set this to `null` to continue using the base `anchor` prop instead of switching to this anchor.
     *
     * @see {@link #anchor}
     */
    belowAnchor: _anchorShape2.default,

    /**
     * This is the position that the children should animate from. It directly ties into
     * the `$md-layover-child-positions` Sass variable.
     */
    animationPosition: _positionShape2.default.isRequired,

    /**
     * If you  would the the layover to interact as a context menu, provide this prop. It will
     * make the children appear relative to the context menu origin automatically.
     *
     * @see {@link #preventContextMenu}
     */
    onContextMenu: _propTypes2.default.func,

    /**
     * Boolean if the default behavior of the context menu should be prevented when using the
     * `onContextMenu` prop.
     *
     * @see {@link #onContextMenu}
     */
    preventContextMenu: _propTypes2.default.bool,

    /**
     * Boolean if the layover should attempt to automatically adjust the position of the element to
     * keep it within the viewport. If this value is set to `false`, the `onClose` prop will be called
     * instead.
     */
    repositionOnScroll: _propTypes2.default.bool
  };
  Layover.defaultProps = {
    anchor: {
      x: Layover.HorizontalAnchors.INNER_LEFT,
      y: Layover.VerticalAnchors.OVERLAP
    },
    belowAnchor: {
      x: Layover.HorizontalAnchors.CENTER,
      y: Layover.VerticalAnchors.BOTTOM
    },
    animationPosition: Layover.Positions.BELOW,
    repositionOnScroll: true,
    component: 'div',
    fixedTo: typeof window !== 'undefined' ? window : {},
    toggleQuery: '.md-text-field-container,button,*[role="button"],*[role="listbox"]',
    transitionName: 'md-layover',
    transitionEnterTimeout: 200,
    transitionLeaveTimeout: 200,
    yThreshold: 0.38,
    xThreshold: 0.38,
    closeOnOutsideClick: true,
    preventContextMenu: true
  };

  var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this._manageFixedToListener = function (fixedTo, add) {
      var listener = (add ? 'add' : 'remove') + 'EventListener';
      if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {
        var x = fixedTo.x,
            y = fixedTo.y;

        if (x) {
          x[listener]('scroll', _this3._handleScroll);
        } else {
          window[listener]('scroll', _this3._handleScroll);
        }

        if (y) {
          y[listener]('scroll', _this3._handleScroll);
        } else if (!x) {
          // Only add the window event listener once
          window[listener]('scroll', _this3._handleScroll);
        }

        if (y && y !== window && x && x !== window) {
          window[listener]('scroll', _this3._handleScroll);
        }
      } else {
        fixedTo[listener]('scroll', _this3._handleScroll);

        if (fixedTo !== window) {
          window[listener]('scroll', _this3._handleScroll);
        }
      }
    };

    this._mergeStyles = function (style) {
      return _extends({}, _this3.state.styles, style, _react2.default.Children.only(_this3.props.children).props.style);
    };

    this._init = function (fixedTo, anchor, sameWidth, centered, rect) {
      var centeredDialog = _this3._dialog && _this3._dialog.classList.contains('md-dialog--centered');
      var height = rect.height,
          width = rect.width;
      var top = rect.top,
          left = rect.left,
          right = rect.right;

      var x = void 0;
      var y = void 0;
      if (_this3._dialog) {
        var scroll = (0, _getScroll2.default)(_this3._dialog);
        x = scroll.x;
        y = scroll.y;

        if (centeredDialog) {
          var dialogRect = _this3._dialog.getBoundingClientRect();
          left -= dialogRect.left;
          top -= dialogRect.top;
          right -= dialogRect.right;
        }
      } else if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {
        x = (0, _getScroll2.default)(fixedTo.x || window).x;
        y = (0, _getScroll2.default)(fixedTo.y || window).y;
      } else {
        var _scroll = (0, _getScroll2.default)(fixedTo);
        x = _scroll.x;
        y = _scroll.y;
      }

      _this3._initialX = x;
      _this3._initialY = y;
      _this3._initialLeft = left;
      _this3._initialTop = top;

      if (anchor.x === _HorizontalAnchors2.default.INNER_RIGHT) {
        _this3._initialLeft = left + width;
      } else if (anchor.x === _HorizontalAnchors2.default.RIGHT) {
        _this3._initialLeft = right;
      }

      if (!centered) {
        _this3._lastYFix = anchor.y === _VerticalAnchors2.default.TOP ? 'bottom' : 'top';
      } else {
        // Centered is not fixable
        _this3._lastYFix = null;
      }
      if (anchor.x === _HorizontalAnchors2.default.LEFT || anchor.x === _HorizontalAnchors2.default.INNER_LEFT) {
        _this3._lastXFix = 'right';
      } else if (anchor.x === _HorizontalAnchors2.default.RIGHT || anchor.x === _HorizontalAnchors2.default.INNER_RIGHT) {
        _this3._lastXFix = 'left';
      } else {
        // Can't fix others
        _this3._lastXFix = null;
      }

      if (anchor.y === _VerticalAnchors2.default.BOTTOM) {
        _this3._initialTop = top + height;
      }

      if (fixedTo !== window && !fixedTo.y && !fixedTo.x) {
        var _scroll2 = (0, _getScroll2.default)(window);
        _this3._initialWinX = _scroll2.x;
        _this3._initialWinY = _scroll2.y;
      }

      var styles = _this3._mergeStyles({
        left: _this3._initialLeft,
        top: _this3._initialTop,
        transformOrigin: undefined,
        width: sameWidth ? width : undefined
      });

      _this3.setState({ styles: styles });
    };

    this._setContainer = function (container) {
      _this3._container = (0, _reactDom.findDOMNode)(container);
      _this3._toggle = null;
      if (!_this3._container) {
        return;
      }

      var _props4 = _this3.props,
          toggleQuery = _props4.toggleQuery,
          onContextMenu = _props4.onContextMenu;

      if (typeof toggleQuery === 'function') {
        _this3._toggle = toggleQuery();
      } else if (typeof toggleQuery === 'string') {
        _this3._toggle = _this3._container.querySelector(toggleQuery);
      } else {
        _this3._toggle = toggleQuery;
      }

      if (!_this3._toggle && !onContextMenu && process.env.NODE_ENV !== 'production') {
        var error = new Error('Unable to find a toggle component with the provided `toggleQuery` and `toggle` element. \n' + ('`toggleQuery`: `' + toggleQuery + '`'));
        error.toggleQuery = toggleQuery;
        error.toggle = _this3.props.toggle;

        throw error;
      }

      var node = _this3._container;
      while (node) {
        var fixed = window.getComputedStyle(node).position === 'fixed';
        if (fixed && node.classList.contains('md-dialog--full-page')) {
          _this3._dialog = node;
          return;
        } else if (fixed && node.classList.contains('md-dialog-container')) {
          _this3._dialog = node.firstChild;
          return;
        } else if (fixed && !node.classList.contains('md-layover-child')) {
          _this3._inFixed = true;
          return;
        }

        node = node.offsetParent;
      }
    };

    this._initialFix = function () {
      // Need to make a clone that disables any transitions to calculate positioning stuff
      var clone = _this3._child.cloneNode(true);
      clone.style.webkitTransform = 'none';
      clone.style.transfrom = 'none';
      clone.style.webkitTransition = 'none';
      clone.style.transition = 'none';

      _this3._child.parentNode.appendChild(clone);
      var vp = (0, _viewport2.default)(clone);
      _this3._child.parentNode.removeChild(clone);

      if (vp === true || !_this3._toggle || !_this3._child) {
        return;
      }

      var _getAnchor2 = _this3._getAnchor(_this3.props),
          x = _getAnchor2.x,
          y = _getAnchor2.y;

      var _child = _this3._child,
          childHeight = _child.offsetHeight,
          childWidth = _child.offsetWidth;

      var toggleHeight = void 0;
      var toggleWidth = void 0;
      if (_this3._contextRect) {
        toggleHeight = _this3._contextRect.height;
        toggleWidth = _this3._contextRect.width;
      } else {
        toggleHeight = _this3._toggle.offsetHeight;
        toggleWidth = _this3._toggle.offsetWidth;
      }

      var addToTop = 0;
      var addToLeft = 0;
      if (!vp.top || !vp.bottom) {
        var multiplier = vp.top ? -1 : 1;
        if (!vp.bottom && y === _VerticalAnchors2.default.OVERLAP) {
          addToTop += toggleHeight;
        } else if (y === _VerticalAnchors2.default.TOP || y === _VerticalAnchors2.default.BOTTOM) {
          addToTop += multiplier * toggleHeight;
        }

        addToTop += multiplier * childHeight;

        _this3._lastYFix = vp.top ? 'bottom' : 'top';
      }

      if (x !== _HorizontalAnchors2.default.CENTER && (!vp.left || !vp.right)) {
        if (!vp.left && x === _HorizontalAnchors2.default.LEFT) {
          addToLeft += toggleWidth + childWidth;
          _this3._lastXFix = 'left';
        } else if (!vp.left && x === _HorizontalAnchors2.default.INNER_LEFT) {
          addToLeft += toggleWidth;
          _this3._lastXFix = 'left';
        } else if (!vp.right && x === _HorizontalAnchors2.default.RIGHT) {
          addToLeft -= toggleWidth + childWidth;
          _this3._lastXFix = 'right';
        } else if (!vp.right && x === _HorizontalAnchors2.default.INNER_RIGHT) {
          addToLeft -= toggleWidth;
          _this3._lastXFix = 'right';
        }
      }

      if (addToTop !== 0 || addToLeft !== 0) {
        _this3._initialTop += addToTop;
        _this3._initialLeft += addToLeft;

        _this3.setState({ styles: _this3._mergeStyles({ top: _this3._initialTop, left: _this3._initialLeft }) });
      }
    };

    this._fixateChild = function (child) {
      _this3._child = (0, _reactDom.findDOMNode)(child);

      if (_this3._child !== null) {
        window.addEventListener('resize', _this3._handleWindowResize);
        _this3._childComponent = _react2.default.Children.only(_this3.props.children);

        // If child also has a ref callback, simulate the same thing
        if (typeof _this3._childComponent.ref === 'function') {
          _this3._childComponent.ref(child);
        }

        if (!_this3._child || !_this3._toggle && !_this3._contextRect) {
          return;
        }

        if (_this3._dialog && _this3._dialog.classList.contains('md-dialog--centered')) {
          return;
        }

        _this3._positionChild();
      } else if (_this3._childComponent && typeof _this3._childComponent.ref === 'function') {
        _this3._childComponent.ref(child);
      }
    };

    this._positionChild = function () {
      var centered = _this3.props.centered;

      var anchor = _this3._getAnchor(_this3.props);
      var rect = _this3._contextRect || _this3._toggle.getBoundingClientRect();
      _this3._height = rect.height;
      _this3._width = rect.width;
      var styles = _this3._createStyles(anchor, centered, _this3._child, rect);
      if (styles.top || styles.left) {
        _this3._initialLeft = styles.left || _this3._initialLeft;
        _this3._initialTop = styles.top || _this3._initialTop;
        _this3.setState({ styles: _this3._mergeStyles(styles) }, _this3._initialFix);
      } else {
        _this3._initialFix();
      }
    };

    this._handleResize = function () {
      if (_this3.props.visible) {
        _this3._positionChild();
      }
    };

    this._handleScroll = function (e) {
      if (!_this3.props.repositionOnScroll) {
        _this3._manageFixedToListener(_this3.props.fixedTo, false);
        _this3.props.onClose(e);
      }

      if (!_this3._ticking) {
        requestAnimationFrame(function () {
          return _this3._handleTick(e);
        });
      }

      _this3._ticking = true;
    };

    this._handleTick = function (e) {
      var _props5 = _this3.props,
          fixedTo = _props5.fixedTo,
          xThreshold = _props5.xThreshold,
          yThreshold = _props5.yThreshold;

      var vp = (0, _viewport2.default)(_this3._child);
      if (vp !== true && vp.left && vp.right) {
        var fixed = !_this3._contextRect && _this3._attemptFix(vp);
        if (!fixed) {
          _this3.props.onClose(e);
          _this3._ticking = false;
        }

        return;
      } else if ((0, _isOutOfBounds2.default)(fixedTo, _this3._child, _this3._toggle, yThreshold, xThreshold)) {
        _this3.props.onClose(e);
        _this3._ticking = false;
        return;
      }

      var x = void 0;
      var y = void 0;
      if (_this3._dialog) {
        var scroll = (0, _getScroll2.default)(_this3._dialog);
        x = scroll.x;
        y = scroll.y;
      } else if (fixedTo !== window && (fixedTo.x || fixedTo.y)) {
        x = (0, _getScroll2.default)(fixedTo.x || window).x;
        y = (0, _getScroll2.default)(fixedTo.y || window).y;
      } else {
        var _scroll3 = (0, _getScroll2.default)(fixedTo);
        x = _scroll3.x;
        y = _scroll3.y;
      }

      var winX = void 0;
      var winY = void 0;
      // When using the additional fixedTo stuff, need to also keep track of the entire
      // window's scrolling..
      if (fixedTo !== window && !fixedTo.x && !fixedTo.y) {
        var _scroll4 = (0, _getScroll2.default)(window);
        winX = _scroll4.x;
        winY = _scroll4.y;
      }

      var styles = _this3.state.styles;
      var left = styles.left,
          top = styles.top;

      if (_this3._initialX !== x) {
        left = _this3._initialX - x + _this3._initialLeft;
      }

      if (winX && _this3._initialWinX !== winX) {
        left = _this3._initialWinX - winX + _this3._initialX;
      }

      if (_this3._initialY !== y) {
        top = _this3._initialY - y + _this3._initialTop;
      }

      if (winY && _this3._initialWinY !== winY) {
        top = _this3._initialWinY - winY + _this3._initialTop + (_this3._initialY - y);
      }

      if (styles.top !== top || styles.left !== left) {
        _this3.setState({ styles: _this3._mergeStyles({ left: left, top: top }) }, function () {
          _this3._ticking = false;
        });
      } else {
        _this3._ticking = false;
      }
    };

    this._handleOutsideClick = function (e) {
      if (_this3._contextRect && _this3._child && !_this3._child.contains(e.target) || _this3._container && !_this3._container.contains(e.target)) {
        _this3.props.onClose(e);
      }
    };

    this._handleWindowResize = function (e) {
      _this3.props.onClose(e);
      window.removeEventListener('resize', _this3._handleWindowResize);
    };

    this._attemptFix = function (vp) {
      var _getAnchor3 = _this3._getAnchor(_this3.props),
          x = _getAnchor3.x,
          y = _getAnchor3.y;

      var centered = x === _HorizontalAnchors2.default.CENTER && y === _VerticalAnchors2.default.CENTER && _this3.props.centered;
      if (centered || _this3._lastYFix === 'top' && !vp.top || _this3._lastYFix === 'bottom' && !vp.bottom) {
        return false;
      }

      var _child$getBoundingCli2 = _this3._child.getBoundingClientRect(),
          top = _child$getBoundingCli2.top;

      var childHeight = _this3._child.offsetHeight;
      var toggleHeight = _this3._toggle.offsetHeight;

      var newTop = _this3._initialTop;
      var addToTop = childHeight * (vp.top ? -1 : 1);
      if (y === _VerticalAnchors2.default.OVERLAP) {
        addToTop += (vp.top ? 1 : -1) * toggleHeight;
      } else if (y === _VerticalAnchors2.default.TOP || y === _VerticalAnchors2.default.BOTTOM) {
        addToTop += (_this3._lastYFix === 'top' ? -1 : 1) * toggleHeight;
      }

      if (addToTop !== 0) {
        newTop = top + addToTop;
        _this3._lastYFix = vp.top ? 'bottom' : 'top';
      }

      if (newTop !== _this3._initialTop) {
        _this3._initialTop = newTop;
        var fixedTo = _this3.props.fixedTo;

        var scrollEl = fixedTo;
        if (fixedTo !== window && (fixedTo.y || fixedTo.x)) {
          scrollEl = fixedTo.y || window;
        }

        _this3._initialY = (0, _getScroll2.default)(scrollEl).y;

        _this3.setState({ styles: _this3._mergeStyles({ top: _this3._initialTop }) }, function () {
          _this3._ticking = false;
        });
        return true;
      }

      return false;
    };

    this._handleContextMenu = function (e) {
      var anchor = _this3._getAnchor(_this3.props);
      var _props6 = _this3.props,
          onContextMenu = _props6.onContextMenu,
          preventContextMenu = _props6.preventContextMenu,
          fixedTo = _props6.fixedTo,
          sameWidth = _props6.sameWidth,
          centered = _props6.centered,
          visible = _props6.visible;

      if (!onContextMenu) {
        return;
      }

      _this3._contextRect = (0, _getSelectedTextPosition2.default)(e);
      if (preventContextMenu && (!_this3._child || !_this3._child.contains(e.target))) {
        e.preventDefault();
      }

      // If this isn't done, firefox immediate closes the context menu. :/
      (0, _captureNextEvent2.default)('click');
      onContextMenu(e);
      if (visible) {
        _this3._init(fixedTo, anchor, sameWidth, centered, _this3._contextRect);
      }
    };
  };

  exports.default = Layover;
});